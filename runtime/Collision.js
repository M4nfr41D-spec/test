/* Copyright (c) Manfred Foissner. All rights reserved. */
/* License: See LICENSE.txt in the project root. */

// ============================================================
// Collision.js - World collision & hazard interactions
// ============================================================
// Phase 2.1 implementation:
// - Soft sliding collision for Player/Enemies vs Obstacles (circle vs circle)
// - Bullets vs Obstacles (destructible asteroids/debris)
// - Mines trigger on contact + bullet hit (AoE explosion)
//
// Obstacles are generated by MapGenerator and live in World.currentZone.obstacles:
// { x, y, type, radius, destructible, hp, ... }
//
// Design decisions (Manfred):
// 1) Player collision: soft slide (not hard block)
// 2) Asteroids: destructible by bullets
// 3) Mines: trigger on contact + bullet hit

import { State } from './State.js';
import { Enemies } from './Enemies.js';
import { Player } from './Player.js';
import { Particles } from './Particles.js';

export const Collision = (() => {
  const EPS = 1e-6;

  function distSq(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }

  function normalize(dx, dy) {
    const len = Math.hypot(dx, dy) || 1;
    return { nx: dx / len, ny: dy / len, len };
  }

  // Soft collision resolve: pushes entity out of obstacle and removes velocity component into the obstacle
  function resolveCircleObstacle(entity, obstacle, softness = 1.0) {
    const dx = entity.x - obstacle.x;
    const dy = entity.y - obstacle.y;
    const r = (entity.radius || 10) + (obstacle.radius || 10);
    const d2 = dx * dx + dy * dy;
    if (d2 >= r * r) return false;

    const { nx, ny, len } = normalize(dx, dy);
    const penetration = r - len;

    // Softness: allow a small fraction of overlap for "slide" feel (0..1), but resolve most of it
    const push = penetration * softness;

    entity.x += nx * push;
    entity.y += ny * push;

    // Slide: remove velocity into obstacle normal
    if (typeof entity.vx === 'number' && typeof entity.vy === 'number') {
      const vn = entity.vx * nx + entity.vy * ny; // normal component
      if (vn < 0) {
        entity.vx -= vn * nx;
        entity.vy -= vn * ny;
      }
    }
    return true;
  }

  function triggerMine(zone, mine, source = 'contact') {
    // Remove mine from zone immediately
    mine._dead = true;

    const x = mine.x, y = mine.y;

    const explosionRadius = 140;
    const baseDamage = 30;

    // VFX
    Particles.explosion(x, y, '#ff6622', 24, 220);

    // Damage enemies
    for (const e of State.enemies) {
      if (e.dead) continue;
      const d = Math.hypot(e.x - x, e.y - y);
      if (d <= explosionRadius) {
        const falloff = 1 - (d / explosionRadius);
        const dmg = Math.max(1, Math.round(baseDamage * (0.4 + 0.6 * falloff)));
        Enemies.damage(e, dmg, false);
      }
    }

    // Damage player (if close)
    const p = State.player;
    if (p && !p.dead) {
      const d = Math.hypot(p.x - x, p.y - y);
      if (d <= explosionRadius) {
        const falloff = 1 - (d / explosionRadius);
        const dmg = Math.max(1, Math.round(baseDamage * (0.5 + 0.7 * falloff)));
        Player.takeDamage(dmg);
      }
    }

    // Also damage destructible obstacles slightly (chain reactions optional)
    if (zone?.obstacles) {
      for (const o of zone.obstacles) {
        if (!o || o._dead) continue;
        if (o === mine) continue;
        const d = Math.hypot(o.x - x, o.y - y);
        if (d <= explosionRadius && o.destructible) {
          const falloff = 1 - (d / explosionRadius);
          o.hp = (o.hp ?? 10) - Math.round(12 * falloff);
          if (o.hp <= 0) o._dead = true;
        }
      }
    }
  }

  function resolveEntityVsObstacles(entity, zone, opts = {}) {
    if (!zone || !zone.obstacles || zone.obstacles.length === 0) return;

    const softness = opts.softness ?? 0.9; // soft slide
    const isPlayer = !!opts.isPlayer;

    for (const obs of zone.obstacles) {
      if (!obs || obs._dead) continue;

      // Mines: trigger on contact (3.a)
      if (obs.type === 'mine') {
        const r = (entity.radius || 10) + (obs.radius || 10);
        if (distSq(entity.x, entity.y, obs.x, obs.y) < r * r) {
          triggerMine(zone, obs, 'contact');
          continue;
        }
        // mines still block slightly? keep as obstacle for slide
        resolveCircleObstacle(entity, obs, softness);
        continue;
      }

      // Regular obstacle collision
      resolveCircleObstacle(entity, obs, softness);
    }
  }

  function bulletVsObstacles(bullet, zone) {
    if (!zone || !zone.obstacles || zone.obstacles.length === 0) return false;

    const br = bullet.size || 4;

    for (const obs of zone.obstacles) {
      if (!obs || obs._dead) continue;

      const r = br + (obs.radius || 10);
      if (distSq(bullet.x, bullet.y, obs.x, obs.y) >= r * r) continue;

      // Mine trigger on bullet hit (3.a)
      if (obs.type === 'mine') {
        triggerMine(zone, obs, 'bullet');
        return true;
      }

      // Destructible asteroids/debris (2.a)
      if (obs.destructible) {
        obs.hp = (obs.hp ?? 10) - (bullet.damage || 10);
        Particles.explosion(bullet.x, bullet.y, '#ffffff', 6, 160);

        if (obs.hp <= 0) {
          obs._dead = true;
          Particles.explosion(obs.x, obs.y, '#ffaa66', 18, 200);
          // (Optional) TODO: spawn pickups/debris here
        }
        return true; // bullet consumed
      }

      // Non-destructible (pillar): bullet consumed
      Particles.explosion(bullet.x, bullet.y, '#8899aa', 5, 140);
      return true;
    }

    return false;
  }

  function cleanupZoneObstacles(zone) {
    if (!zone?.obstacles) return;
    for (let i = zone.obstacles.length - 1; i >= 0; i--) {
      if (zone.obstacles[i]?._dead) zone.obstacles.splice(i, 1);
    }
  }

  return {
    resolveEntityVsObstacles,
    bulletVsObstacles,
    cleanupZoneObstacles,
    triggerMine
  };
})();
